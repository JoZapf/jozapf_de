# Technical README — jozapf-de

Created: 2025-10-12 17:05:00 (timestamp in filename)

This document is a detailed, technical and didactic explanation of the project state, what was changed during recent work, and how to operate and deploy the application securely. It focuses on environment handling (env files vs. process environment), HTTP server protection (`.htaccess` / nginx examples), Docker compose behavior, and troubleshooting guidance.

Table of contents
- Summary: project and recent changes
- Contract: how the app reads configuration and secrets (clear rules)
- Files changed (what we edited and why)
- `.htaccess` rules — exact semantics and recommended variants (Apache & nginx)
- Docker / Compose notes (how compose mounts envs and recommended usage)
- Local dev vs Production (Hetzner shared hosting) — safe workflows
- Troubleshooting checklist (common failures and commands)
- Next steps and recommended hardening

## 1) Summary — project and recent changes

This repository provides a hardened contact form with abuse prevention, a small admin dashboard and automated cron-based log anonymization. Recent work addressed environment handling, Docker compose defaults, dashboard authentication, and access control via `.htaccess`:

- Make PHP code prefer process environment variables (getenv/$_ENV) first, then explicit `APP_ENV_FILE`, then webroot `.app.env`/`app.env`, then repo defaults. This allows both containerized and simple shared-host deployments.
- Changed `dashboard-login.php` to support Argon2id hashes (`DASHBOARD_PASSWORD_HASH`) and to set cookies in a PHP-version-compatible manner. Added a cookie compatibility wrapper `set_cookie_compat()`.
- Fixed syntax issues that caused HTTP 500 on the login page and removed redirect-loop causes by aligning env loading between `dashboard-login.php` and `dashboard.php`.
- Adjusted `.htaccess` to explicitly allow the public endpoints needed by the frontend (`dashboard-login.php`, `dashboard.php`, `dashboard-api.php`, `dashboard-blocklist.php`, `contact-php-handler.php`) while blocking internal helpers and sensitive files.
- Adjusted `cron/anonymize-logs.php` and other cron-related code so it can read secrets from a mounted `app.env` or `.app.env` and inject them into the process environment (so `getenv()` works for cron invocations).

These changes were intentionally minimal and conservative. The main goal: keep secrets out of the repository while ensuring that both Docker-based development and shared-host production work with a single, predictable loading strategy.

## 2) Contract: how configuration and secrets are resolved (canonical order)

Design contract — the application follows a small deterministic priority list when resolving configuration keys (for example `DASHBOARD_SECRET`, `SMTP_HOST`, `RECIPIENT_EMAIL`):

1. Process environment (getenv() / $_ENV) — keys injected at process start (preferred).
2. `APP_ENV_FILE` if defined and points to a readable file — you can set this in Docker compose or in a wrapper script for cron.
3. Files in these candidate paths (checked in order):
   - `assets/php/.env.prod` (legacy)
   - `assets/php/.app.env`
   - `assets/php/app.env`
   - project webroot `/.app.env`
   - project webroot `/app.env`
   - project webroot `/.env` (fallback)
4. Built-in defaults in code (very rare and non-sensitive; these are present in `assets/php/.env.compose` and similar files)

Why this order?
- Process env first: this is the safest and most flexible for containers, systemd EnvironmentFile, or temporary overrides.
- `APP_ENV_FILE` explicit file path is a deterministic hook used by Compose to bind-mount a secret file into the container and tell the app where to find it.
- Webroot candidate files are accepted to support simple shared-host setups where placing a file outside the webroot is not possible. In such environments you must apply server rules to ensure the env file is never served.

Security note: In production always prefer process env or `APP_ENV_FILE` pointing to a file outside the webroot. `.app.env` in the webroot is only a pragmatic fallback when you cannot place files outside the served directory.

## 3) Files changed (what, where, why)

- `assets/php/_env_check.php` (modified)
  - Purpose: deterministic dotenv loader and helper functions. Now prefers process env and `APP_ENV_FILE` and checks multiple candidate files in the order described above.

- `assets/php/dashboard-login.php` (modified)
  - Purpose: login page and token generation. Fixed PHP parse errors, added `set_cookie_compat()` to support PHP versions older than 7.3, and made env() read process env first. Supports `DASHBOARD_PASSWORD_HASH` with `password_verify()`.

- `assets/php/dashboard.php` (modified)
  - Purpose: dashboard view and client-side JS. Aligned `env()` loader with same behavior as login. Client-side JS Fetch calls changed to `credentials: 'same-origin'` and now check the `Content-Type` before JSON parsing to avoid "Unexpected token '<'" when the server returns HTML.

- `cron/anonymize-logs.php` (modified)
  - Purpose: cron job. Now attempts to load secrets from `APP_ENV_FILE` or `SECRETS_DIR` candidates and injects them into `$_ENV`/getenv(). Also reads `CRON_PUBLIC_HTML` and `PROJECT_NAME` from process env first.

- `assets/php/dashboard-api.php` (modified)
  - Purpose: backend JSON API for the dashboard. Now enforces token validation on every request (cookie `dashboard_token` or `Authorization: Bearer <token>`). Returns JSON with HTTP 401 when the token is missing and HTTP 403 when the token is invalid or expired. This prevents HTML login redirects from being returned to AJAX clients.

- `compose.yml` (modified)
  - Purpose: Docker compose. Changes: mount project root to `/var/www/html`, bind repo `.env` into container webroot, set default build target to `prod` to avoid Xdebug pecl build by default, and provide `env_file` mapping to `${SECRETS_DIR}/app.env`.

- `/.htaccess` (modified)
  - Purpose: global webroot security + redirects. Adjusted to explicitly allow public endpoints and block other `assets/php` internals. The `FilesMatch` rule was adjusted to protect `app.env` and `.app.env` (both) and other sensitive patterns.

If you need the exact diffs, check your VCS. The changes were aimed at making the minimum edits to fix runtime errors, unify secret loading and avoid exposing secrets in the repo.

## 4) `.htaccess` — exact semantics, rationale and recommended rules

This project supports both Apache `.htaccess` and nginx server-blocks. The goal is to:

1. Deny access to sensitive files (env files, logs, internal PHP classes).
2. Allow only the public endpoints required by the UI and API.
3. Preserve useful site-wide rewrites (HTTPS canonicalization) but avoid over-broad blocks that break AJAX/API endpoints or the contact form handler.

Below are recommended snippets.

Apache root `.htaccess` (recommended, annotated):

```apache
# Enable rewrite engine (required for redirects)
<IfModule mod_rewrite.c>
  RewriteEngine On

  # 1) Redirect HTTP and non-canonical hosts to canonical https://jozapf.de
  #    (Example; adapt to your preferred canonical host)
  RewriteCond %{HTTPS} !=on [OR]
  RewriteCond %{HTTP_HOST} ^www\.jozapf\.de$ [NC]
  RewriteRule ^ https://jozapf.de%{REQUEST_URI} [R=301,L]

  # 2) Block dotfiles (except .well-known for Let's Encrypt)
  RewriteRule "(^|/)\.(?!well-known/)" - [F]

  # 3) Block common config files and explicitly protect env files
  #    Protect both 'app.env' and '.app.env' (with or without leading dot)
  RewriteRule "(^|/)(\.?app\.env|composer\.(json|lock)|package(-lock)?\.json|yarn\.lock|wp-config\.php(\.bak)?|config\.(json|ya?ml)|\.env(\..*)?)$" - [F]

  # 4) Allow only listed public PHP endpoints under assets/php
  #    (dashboard, API, contact handler). Everything else in assets/php is blocked.
  RewriteRule ^assets/php/(dashboard-login\.php|dashboard\.php|dashboard-api\.php|dashboard-blocklist\.php|contact-php-handler\.php)$ - [L]
  RewriteRule ^assets/php/ - [F]
</IfModule>

# Deny access to logs and other artifacts
<IfModule mod_authz_core.c>
  <FilesMatch "\.log$">
    Require all denied
  </FilesMatch>
</IfModule>

# Turn off PHP error display (don’t reveal details to public)
php_flag display_errors Off
```

Notes:
- The `RewriteRule ^assets/php/ - [F]` is a defensive default. Only explicitly allowed endpoints are permitted. This prevents accidental exposure of helper scripts or internal APIs.
- If you prefer to allow more endpoints, add them to the allowed regex.
- If your host does not support `.htaccess`, use the equivalent nginx rules (examples below).

Nginx equivalents (server block snippets):

```nginx
# HTTP -> HTTPS redirect for all hosts
server {
  listen 80;
  server_name jozapf.de www.jozapf.de jozapf.com www.jozapf.com;
  return 301 https://jozapf.de$request_uri;
}

# HTTPS canonical host
server {
  listen 443 ssl http2;
  server_name jozapf.de;
  ssl_certificate /etc/letsencrypt/live/jozapf.de/fullchain.pem;
  ssl_certificate_key /etc/letsencrypt/live/jozapf.de/privkey.pem;

  # Block access to dotfiles
  location ~ (^|/)\.(?!well-known/) {
    deny all;
  }

  # Block specific filenames globally
  location ~* (\.?app\.env|\.env(\..*)?|composer\.(json|lock)|package(-lock)?\.json|yarn\.lock)$ {
    deny all;
  }

  # Allow the public endpoints in assets/php and deny others
  location = /assets/php/dashboard-login.php { include fastcgi_params; fastcgi_pass unix:/run/php/php-fpm.sock; }
  location = /assets/php/dashboard.php { include fastcgi_params; fastcgi_pass unix:/run/php/php-fpm.sock; }
  location = /assets/php/dashboard-api.php { include fastcgi_params; fastcgi_pass unix:/run/php/php-fpm.sock; }
  location = /assets/php/dashboard-blocklist.php { include fastcgi_params; fastcgi_pass unix:/run/php/php-fpm.sock; }
  location = /assets/php/contact-php-handler.php { include fastcgi_params; fastcgi_pass unix:/run/php/php-fpm.sock; }

  # Default deny for assets/php
  location /assets/php/ { deny all; }

  # ... rest of your site config
}
```

## 5) Docker Compose notes (how compose mounts and env_file works)

Key points from `compose.yml`:

- The compose file uses `env_file: "${SECRETS_DIR}/app.env"`. This loads env vars into container processes (equivalent to process environment). This is preferred for secrets.
- Additionally the compose file bind-mounts the host `app.env` into the container at `/var/www/html/assets/php/app.env`. This is useful when application code reads a dotenv file directly.
- The `APP_ENV_FILE` environment variable is set in the compose environment to `/var/www/html/assets/php/app.env` — this tells the application loader where to find an env file if it needs to.

Recommendations for development vs production:

- Development (local, Docker): Keep secrets in a host directory outside the repo, e.g. `E:/Secrets/jozapf-de/app.env` and set `SECRETS_DIR` in the project's `.env` so `docker compose` knows where to load it from. Use MailHog for SMTP testing (no auth, port 1025).
- Production (Shared Host): Prefer placing sensitive secrets outside of webroot and expose them to PHP through the environment or with a systemd `EnvironmentFile`. If you cannot place files outside the webroot, use `/.app.env` but ensure server rules prevent access and set file permissions to `600`.

Docker pitfalls to avoid:
- Do not commit `app.env` to the repo. Add it to `.gitignore`.
- Make sure the `env_file` path exists on the host when you run `docker compose` — otherwise Compose may warn about uninitialized variables and default them to blank.

## 6) Local dev / Production differences and step-by-step deploy (practical)

Local dev (Docker):

1. Create host secrets dir (outside repo): `E:/Secrets/jozapf-de/app.env` (Windows example).
2. Add `SECRETS_DIR=E:/Secrets/jozapf-de` to project `.env` (non-secret file in repo).
3. Start compose: `docker compose up -d` (use `.env` for interpolation). Docker will load secrets into process env and mount file to `/var/www/html/assets/php/app.env`.

Production (Hetzner shared hosting, no systemd):

1. Upload code to webroot (without `.app.env`). Ensure `.app.env` is listed in `.gitignore`.
2. Create `.app.env` in project webroot with production values. Set ownership to your deployment user and run:

```bash
chown <user>:<group> .app.env
chmod 600 .app.env
```

3. Ensure `.htaccess` (or nginx config) blocks access to `.app.env` as shown earlier.
4. Cron: use a wrapper script that `set -a; . ./.app.env; set +a; php cron/anonymize-logs.php` so the cron process sees the env.

## 7) Troubleshooting checklist (quick actionable)

- 403 on endpoints
  - Check `/ .htaccess` rules and `assets/php/.htaccess`. Ensure public endpoints are allowed. Look at server access/error logs.

- 500 on pages
  - Check PHP error log and Apache/Nginx error_log. On file edits, run `php -l file.php` for syntax check.

- Contact form says "Failed to send message"
  - Check `assets/php/logs` for `mail-debug.log` or `sent-eml/` directory. Verify SMTP values in `.app.env`/process env. For dev, verify MailHog UI.

- Dashboard shows "Unexpected token '<'"
  - The API returned HTML (login redirect) instead of JSON. Ensure `dashboard-api.php` returns 401/403 JSON or that the client sends cookies with `credentials: 'same-origin'`. We updated the JS to do this.

- Redirect loops after login
  - Check cookie attributes (Path, Secure, SameSite). Secure requires HTTPS; if testing on HTTP set `secure=false` temporarily.

## 8) Next steps and hardening recommendations

1. Move secrets to a system-level secret store if available (Docker secrets, systemd `EnvironmentFile` outside webroot or a proper secret manager like Vault) and update code to read from process env.
2. Consider tightening `dashboard-api.php` to require token on every request (if you want the API callable independently). Current approach assumes the dashboard view already validated the token.
3. Add monitoring for 403/401 spikes (could indicate attempted scraping or broken deploys).
4. Consider using a centralized logging or SIEM for long-term analysis.

## 9) Closing notes — current vs previous project state

Previously:
- Env loading was inconsistent: some scripts read `assets/php/.env.prod` only, which resulted in missing secrets when Compose injected variables via `env_file` or when `.app.env` lived in the webroot.
- Docker Compose attempted to build a `dev` image by default (Xdebug) and that could fail during `docker compose build` if pecl/xdebug failed to compile.
- `.htaccess` rules were overly broad and blocked API/contact endpoints.

Now (current state):
- Env loading is unified: getenv() → APP_ENV_FILE → webroot files → defaults. This supports both secure containerized deploys (preferred) and pragmatic shared-host setups.
- Compose default target is `prod` (no Xdebug built by default). Use `DOCKER_TARGET=dev` for development when you need Xdebug.
- `.htaccess` is precise: public endpoints allowed; internal helpers, dotfiles, and env files blocked. JS fetch calls send cookies and check content-type before parsing.

If you want, I will also:
- Create a `DEPLOYMENT.md` with exact commands for Hetzner shared hosting (wrapper script for cron, sample `crontab` entry), or
- Create a `systemd` unit example plus `EnvironmentFile` example (for systems that have systemd), or
- Harden `dashboard-api.php` so it always checks the token and returns proper JSON error codes.

Which of these would you like me to add next? I can implement the chosen document or config file and run a quick validation pass against the codebase.
