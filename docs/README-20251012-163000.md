# Projektübersicht und Deployment-Hinweise

Erstellt: 2025-10-12 16:30:00 (Dateiname enthält Timestamp)

Diese README erklärt auf Deutsch den aktuellen Zustand des Projekts „Advanced Contact Form with Abuse Prevention“, fasst die vorgenommenen Änderungen zusammen und beschreibt einen einfachen, sicheren Deployment-Workflow für Shared-Hosting (z. B. Hetzner). Kommentare im Code und die interne Dokumentation bleiben auf Englisch.

## Aktueller Zustand (Kurzfassung)

- Das Projekt ist funktional und auf Sicherheit gehärtet: Argon2id Passwort-Hashing, HMAC-basierte Token-Authentifizierung, CSRF-Schutz, IP-Rate-Limiting und automatisierte Log-Anonymisierung per Cron.
- Docker-Compose Unterstützung ist vorhanden. Für lokale Entwicklung nutzt Compose eine nicht-öffentliche `app.env` (in einem auf dem Host gespeicherten `SECRETS_DIR`) und ein projektweites `.env` für nicht-geheime Defaults.
- Produktion auf einfachem Shared-Hosting (ohne systemd) wird unterstützt, indem eine `.app.env` im Webroot platziert wird. Die PHP-Skripte und Cron-Skripte lesen Umgebungsvariablen zuerst (getenv/$_ENV) und fallen dann auf Webroot- oder Repo-Env-Dateien zurück.

## Was wurde geändert (Technische Änderungen)

1. Einheitliches Laden von Umgebungsvariablen
   - Die PHP-Utility zum Einlesen von dotenv-Dateien (`assets/php/_env_check.php`) wurde erweitert. Reihenfolge der Priorität:
     1. Prozess-Umgebungsvariablen (getenv/$_ENV)
     2. Explizit gesetzte `APP_ENV_FILE` (z. B. durch Docker-Compose gemountet)
     3. Webroot-Dateien: `.app.env`, `app.env`, `.env`
     4. Projekt-/assets-Defaults (z. B. `assets/php/.env.compose`)
   - Damit funktionieren sowohl lokale Docker-Setups (mit `SECRETS_DIR/app.env`) als auch Shared-Hosting, wo die Datei im Webroot liegt.

2. Dashboard-Login und Passwort-Handling
   - `assets/php/dashboard-login.php` akzeptiert nun `DASHBOARD_PASSWORD_HASH` (Argon2id) und prüft Logins mit `password_verify()`.
   - Falls kein Hash vorhanden ist, fällt die Logik auf `DASHBOARD_PASSWORD` (Plaintext) zurück — dies ist nur eine Kompatibilitäts-Fallback und wird nicht empfohlen.

3. Cron-Skript resilient gegenüber unterschiedlichen Secret-Locations
   - `cron/anonymize-logs.php` lädt jetzt Secrets aus `APP_ENV_FILE`, aus `SECRETS_DIR/app.env` (wenn gesetzt) oder aus Webroot `.app.env` und injiziert sie in die Prozessumgebung, bevor Pfade wie `CRON_PUBLIC_HTML` oder `PROJECT_NAME` ausgewertet werden.

4. API-Härtung: `dashboard-api.php` verlangt jetzt auf jedem Request eine gültige Dashboard-Authentifizierung
   - Die API prüft nun auf jedem Aufruf das HMAC-Token. Der Token kann entweder per Cookie `dashboard_token` oder per HTTP-Header `Authorization: Bearer <token>` übergeben werden.
   - Bei fehlendem Token liefert die API eine JSON-Antwort mit HTTP-Status 401 (unauthorized). Bei ungültigem oder abgelaufenem Token kommt HTTP-Status 403 (forbidden) mit einer JSON-Antwort.
   - Diese Änderung verhindert, dass AJAX-Clients unbeabsichtigt HTML-Login-Redirects statt JSON erhalten (das verursachte zuvor "Unexpected token '<'"-Fehler im Dashboard).

4. Docker / Compose Anpassungen
   - `compose.yml` wurde so angepasst, dass der Projekt-Root in den Container gemountet wird (`/var/www/html`) und die lokale `.env` in das Webroot (`/var/www/html/.env`) gebunden wird.
   - Die Standard-Build-Stage im PHP-Dockerfile ist jetzt `prod`, Xdebug wird nicht standardmäßig gebaut. Für Entwicklung kann `DOCKER_TARGET=dev` genutzt werden.


## Empfohlene Datei- und Secrets-Konvention

- Entwicklungsmaschine (lokal, Docker):
  - Platzieren Sie sensible Werte in einer Datei `app.env` außerhalb des Repos, z. B. `E:/Secrets/jozapf-de/app.env`.
  - Setzen Sie in der Projekt-`.env` (nicht sensibel) `SECRETS_DIR=E:/Secrets/jozapf-de`.
  - Docker-Compose lädt diese Datei per `env_file:` und bind-mountet sie ins Container-Webroot unter `/var/www/html/assets/php/app.env`.

- Produktion (Shared-Hosting ohne systemd, z. B. Hetzner):
  - Legen Sie eine Datei `.app.env` (oder `app.env`) in das Webroot des Projekts, also dort wo `index.html` liegt.
  - Die Anwendung und Cron-Skripte suchen zuerst nach Prozess-Umgebungsvariablen, dann nach `APP_ENV_FILE`, dann nach `.app.env`/`app.env` im Webroot. Das erlaubt einfache Deployments auf Shared-Hosts.
  - Achten Sie unbedingt auf Dateiberechtigungen: `.app.env` darf nicht öffentlich auslesbar sein (setzen Sie CHMOD 600 / passender Besitzer).


## Einfacher Deployment-Workflow (Shared-Hosting, Hetzner Beispiel)

1. Vorbereitung (lokal):
   - Erstelle in deiner lokalen Umgebung eine Datei `app.env` mit sensiblen Werten (DASHBOARD_SECRET, DASHBOARD_PASSWORD_HASH, DB_PASS, SMTP-LOGIN etc.).
   - Prüfe lokal mit Docker-Compose (optional): `docker compose up -d` (achte darauf, dass in deiner Projekt-`.env` `DOCKER_TARGET=prod` steht, um nicht automatisch Xdebug zu bauen).

## DEPLOYMENT.md
Wenn du möchtest, erstelle ich jetzt noch die systemd- und crontab-Vorlagen sowie eine kurze `DEPLOYMENT.md` mit Schritt-für-Schritt-Anweisungen für Hetzner Shared Hosting.

2. Deployment auf Shared-Host:
   - Übertrage nur den erforderlichen Projektcode (ohne lokale `app.env`) z. B. per FTP/SFTP oder Git (bei Git: setze `.gitignore` so, dass `.app.env` nicht ins Repo kommt).
   - Lege im Webroot eine Datei `.app.env` an (oder `app.env`, beide werden erkannt) mit denselben Schlüsseln wie lokal.
   - Setze Dateiberechtigungen restriktiv (Beispiel, über SSH):
     - `chown <user>:<group> .app.env`
     - `chmod 600 .app.env`

3. Cron einrichten (Shared-Hosting):
   - Wenn das Hosting nur klassische Cronjobs anbietet, nutze einen Crontab-Eintrag, der PHP direkt aufruft. Beispiel:

```powershell
# Beispiel für pwsh/SSH-Befehle, tatsächliche Cron-Zeile bleibt auf dem Server im crontab:
# crontab -e
# Alle 24 Stunden um 03:15
15 3 * * * /usr/bin/php /pfad/zum/webroot/cron/anonymize-logs.php >> /var/log/jozapf-anonymize.log 2>&1
```

   - Wichtiger Hinweis: Das Cron-Skript lädt `.app.env` aus dem Webroot, sofern keine Prozess-Umgebungsvariablen gesetzt sind.

4. Tests nach dem Deployment:
   - Rufe die Dashboard-Login-URL auf und versuche dich mit einem (getesteten) Admin-User einzuloggen.
   - Überprüfe, ob `DASHBOARD_SECRET` und `DASHBOARD_PASSWORD_HASH` korrekt gesetzt sind, sonst schlägt die Anmeldung fehl.
   - Schau in die Log-Dateien (`assets/php/logs/` und das Cron-Log), ob Anonymisierung und Login-Fehler protokolliert werden.


## Sicherheitsempfehlungen

- Vermeide, Klartext-Passwörter in der Produktions-Env: nutze `DASHBOARD_PASSWORD_HASH` (Argon2id). Erzeuge ihn lokal mit PHP oder einem kleinen Script.
- Schütze `.app.env` vor Webzugriff (Webserver so konfigurieren, dass Dateien mit Punktpräfix nicht ausgeliefert werden oder nutze einen sicheren Pfad außerhalb des Webroots, sofern möglich).
- Betrachte langfristig Docker Secrets, systemd `EnvironmentFile` (wenn systemd verfügbar) oder einen Secret-Manager (HashiCorp Vault, Cloud Secrets) für bessere Sicherheit.


## Troubleshooting (häufige Punkte)

- „The 'PROJECT_SLUG' variable is not set. Defaulting to a blank string.“
  - Ursache: `compose.yml` verwendet interpolierte Variablen. Lege eine Projekt-`.env` im Repo-Root an (nicht sensibel) oder exportiere die Variable in deiner Shell.

- Xdebug-Build-Fehler beim `docker build`
  - Ursache: Der Dev-Stage build versucht `pecl install xdebug`. Setze `DOCKER_TARGET=prod` in der Projekt-`.env` oder exportiere diese Variable, um das Standard-Buildziel zu ändern.

- Login schlägt fehl wegen fehlendem Secret
  - Ursache: `DASHBOARD_SECRET` oder `DASHBOARD_PASSWORD_HASH` nicht gesetzt. Prüfe zuerst Prozess-Umgebungsvariablen, sonst `.app.env` im Webroot.


## Nächste Schritte / Empfehlungen

1. Kurzfristig: Ergänze diese README um serverseitige Cron-/systemd-Beispiele (ich kann das übernehmen) und prüfe die Deploy-Pfade für Hetzner.
2. Mittelfristig: Überführe sensible Werte in einen System-Secret-Store oder sichere sie mit Platform-spezifischen Mechanismen.
3. Langfristig: Dokumentiere ein standardisiertes Release/Deploy-Skript (z. B. `deploy.sh`) und minimale Tests, die nach jedem Deploy laufen.


---

Wenn du möchtest, erstelle ich jetzt noch die systemd- und crontab-Vorlagen sowie eine kurze `DEPLOYMENT.md` mit Schritt-für-Schritt-Anweisungen für Hetzner Shared Hosting.
